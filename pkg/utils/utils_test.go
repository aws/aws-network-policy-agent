package utils

import (
	"net"
	"testing"

	corev1 "k8s.io/api/core/v1"

	"github.com/achevuru/aws-network-policy-agent/api/v1alpha1"
	"github.com/stretchr/testify/assert"
	ctrl "sigs.k8s.io/controller-runtime"
)

func TestComputeTrieKey(t *testing.T) {

	_, hostCIDR, _ := net.ParseCIDR("10.1.1.2/32")
	_, nonHostCIDR, _ := net.ParseCIDR("10.1.1.0/24")

	type args struct {
		IPNet net.IPNet
	}

	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "Host CIDR",
			args: args{
				IPNet: *hostCIDR,
			},
			want: []byte{0x20, 0x00, 0x00, 0x00, 0x0a, 0x01, 0x01, 0x02},
		},

		{
			name: "Non-Host CIDR",
			args: args{
				IPNet: *nonHostCIDR,
			},
			want: []byte{0x18, 0x00, 0x00, 0x00, 0x0a, 0x01, 0x01, 0x02},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ComputeTrieKey(tt.args.IPNet, false)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestComputeTrieValue(t *testing.T) {
	test_utilsLogger := ctrl.Log.WithName("ebpf-client")
	protocolTCP := corev1.ProtocolTCP
	protocolUDP := corev1.ProtocolUDP
	protocolSCTP := corev1.ProtocolSCTP

	var testPort80, testPort81 int32
	testPort80 = 80
	testPort81 = 81

	type args struct {
		Ports    []v1alpha1.Port
		allowAll bool
		denyAll  bool
	}

	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "TCP on Port 80",
			args: args{
				Ports: []v1alpha1.Port{
					{
						Protocol: &protocolTCP,
						Port:     &testPort80,
					},
				},
			},
			want: []byte{0x06, 0x00, 0x00, 0x00, 0x50, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},

		{
			name: "UDP on Port 80",
			args: args{
				Ports: []v1alpha1.Port{
					{
						Protocol: &protocolUDP,
						Port:     &testPort80,
					},
				},
			},
			want: []byte{0x11, 0x00, 0x00, 0x00, 0x50, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},

		{
			name: "SCTP on Port 80",
			args: args{
				Ports: []v1alpha1.Port{
					{
						Protocol: &protocolSCTP,
						Port:     &testPort80,
					},
				},
			},
			want: []byte{0x84, 0x00, 0x00, 0x00, 0x50, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},
		{
			name: "TCP on Port 80 and UDP on Port 81",
			args: args{
				Ports: []v1alpha1.Port{
					{
						Protocol: &protocolTCP,
						Port:     &testPort80,
					},
					{
						Protocol: &protocolUDP,
						Port:     &testPort81,
					},
				},
			},
			want: []byte{0x06, 0x00, 0x00, 0x00, 0x50, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x11, 0x00, 0x00, 0x00, 0x51, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},
		{
			name: "TCP on Port 80, UDP on Port 81 and SCTP on Port 80",
			args: args{
				Ports: []v1alpha1.Port{
					{
						Protocol: &protocolTCP,
						Port:     &testPort80,
					},
					{
						Protocol: &protocolUDP,
						Port:     &testPort81,
					},
					{
						Protocol: &protocolSCTP,
						Port:     &testPort80,
					},
				},
			},
			want: []byte{0x06, 0x00, 0x00, 0x00, 0x50, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x11, 0x00, 0x00, 0x00, 0x51, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x84, 0x00, 0x00, 0x00, 0x50, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},

		{
			name: "Allow All scenario",
			args: args{
				Ports:    []v1alpha1.Port{},
				allowAll: true,
				denyAll:  false,
			},
			want: []byte{0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},
		{
			name: "Except CIDR scenario",
			args: args{
				Ports:    []v1alpha1.Port{},
				allowAll: false,
				denyAll:  true,
			},
			want: []byte{0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ComputeTrieValue(tt.args.Ports, test_utilsLogger, tt.args.allowAll, tt.args.denyAll)
			assert.Equal(t, tt.want, got)
		})
	}
}
